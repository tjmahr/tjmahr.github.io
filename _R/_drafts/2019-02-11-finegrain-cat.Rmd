---
title: Draft post (2019-02-11)
excerpt: ''
tags: ''
header:
  overlay_image: "assets/images/marisa-morton-1280.jpg"
  image_description: "A wall of donuts"
  overlay_filter: rgba(10, 10, 10, 0.1)
  caption: "Photo credit: [**Yuval Levy**](https://unsplash.com/photos/r3VbEP24__o)"
---



```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this post, I walk through the code I used to make a nice diagram illustrating
the parameters in a logistic growth curve. I made this figure for a conference
submission. I had a tight word limit (600 words) and a complicated
statistical method (Bayesian nonlinear mixed effects beta regression), so I
wanted to use a diagram to carry some of the expository load. Also, figures
didn't count towards the word limit, so that was a bonus.

Here I will cover a few different topics:

- The pieces of the three-parameter logistic equation
- What exactly the murky "scale" parameter does
- How use `mathplot` to add mathematical material to plots
- The divide by four rule for logistic curves



## Growth towards a ceiling

<!-- In Septemer, I started a job as a data scientist for an NIH project studying how -->
<!-- speech, language and communication development in children with cerebral palsy. -->
<!-- My title says assistant scientist, but I call myself a data scientist because I -->
<!-- still do all my work in RStudio and because it makes feel cool. And I study -->
<!-- development -->


Children can be hard to understand; they are learning to talk after all. You
probably can imagine a four-year old asking politely asking for something:
"pwetty pwease". This understandability problem is compounded for children with
cerebral palsy, because these kids will often have speech-motor impairments on
top of the usual developmental patterns. My current project is a statistical
model of how *intelligibility*---the probability that an unfamiliar listener
understands what a child says---develops from age 3 to age 8. 

For example, here are some data. Most of the code revhere is for formatting the
axes.

```{r}
library(tidyverse)
theme_set(theme_minimal())

points <- tibble(
  age = c(38, 45, 52, 61, 80, 74), 
  prop = c(0.146, 0.241, 0.571, 0.745, 0.843, 0.738))

colors <- list(
  data = "#41414580",
  fit = "#414145")

ggplot(points) + 
  aes(x = age, y = prop) + 
  geom_point(size = 3, color = colors$data) +
  scale_x_continuous(
    name = "Age in months", 
    limits = c(0, 96), 
    # Because age is in months, I want breaks to land on multiples
    # of 12. The `Q` in `extended_breaks()` are "nice" numbers to use
    # for axis breaks.
    breaks = scales::extended_breaks(Q = c(24, 12))) + 
  scale_y_continuous(
    name = "Intelligibility",
    limits = c(0, NA),
    labels = scales::percent_format(accuracy = 1))
```


One of the interesting features of speech development is that it finishes:
Children stop making their usual developmental speech patterns and converge on a
mature level of performance. They stop making the stereotypical patterns of
child speech.

For the statistical models, we expected children to follow a certain
developmental trajectory towards this ceiling: Begin at zero intelligibility,
show a period of accelerating then decelerating growth, and finally plateau at
some mature level of ability. This pattern of growth can be modeled using a
logistic growth curve using three parameters: an asymptote, a midpoint when
growth is steepest, and a scale which sets the slope of the curve.

Below is the equation of the logistic growth curve:

$$f(t) = \frac{\text{asymptote}}{1 + \exp{((\text{mid}~-~t)~*~\text{scale})}}$$

But this equation doesn't do us any good. If you are like me, you probably
stopped paying attention when you saw exp() in the denominator. Here's the logistic curve for these data.


```{r}
xs <- seq(0, 96, length.out = 80)

trend <- tibble(
  age = xs,
  asymptote = .8,
  scale = .2,
  midpoint = 48,
  prop = asymptote / (1 + exp((midpoint - age) * scale)))

ggplot(points) + 
  aes(x = age, y = prop) + 
  geom_line(data = trend, color = colors$fit) +
  geom_point(size = 3, color = colors$data) +
  scale_x_continuous(
    name = "Age in months", 
    limits = c(0, 96), 
    breaks = scales::extended_breaks(Q = c(24, 12))) + 
  scale_y_continuous(
    name = "Intelligibility",
    limits = c(0, NA),
    labels = scales::percent_format(accuracy = 1))
```

Now, let's add some labels to mark some key parts of the equation. One
unfamiliar bit of ggplot technology here might be `annotate()`. Geometry
functions like `geom_point()` or `geom_text()` are used to draw data that lives
in a dataframe using aesthetic mappings defined in `aes()`, and these function
draws some geometry (like a point or a label) for each row of the data. For
one-off annotations with `annotate()`, we set the aesthetics manually
instead. The first argument of `annotate()` says what kind of geom to use for
the annotation: `"text"` calls on `geom_text()` and `"segment"` calls on
`geom_segment()`.

<!-- A line  -->
<!-- like `aes(x = age)` tells ggplot "when you draw something, get its *x* position -->
<!-- using the `age` column in the data", and this happens for each row of the data. -->

```{r}
colors$asym <- "#E7552C"
colors$mid <- "#3B7B9E"
colors$scale <- "#1FA35C"

p <- ggplot(points) +
  aes(x = age, y = prop) +
  annotate(
    "segment",
    color = colors$mid,
    x = 48, xend = 48,
    y = 0, yend = .4,
    linetype = "dashed") +
  annotate(
    "segment",
    color = colors$asym,
    x = 20, xend = Inf,
    y = .8, yend = .8,
    linetype = "dashed") +
  geom_line(data = trend, size = 1, color = colors$fit) +
  geom_point(size = 3, color = colors$data) +
  annotate(
    "text",
    label = "growth plateaus at asymptote",
    x = 20, y = .84,
    # horizontal justification = 0 sets x position to left edge of text
    hjust = 0,
    color = colors$asym) +
  annotate(
    "text",
    label = "growth steepest at midpoint",
    x = 49, y = .05,
    hjust = 0,
    color = colors$mid) +
  scale_x_continuous(
    name = "Age in months", 
    limits = c(0, 96), 
    breaks = scales::extended_breaks(Q = c(24, 12))) + 
  scale_y_continuous(
    name = "Intelligibility",
    limits = c(0, NA),
    labels = scales::percent_format(accuracy = 1))

p
```

But how do we represent scale?












## We need to talk about the scale parameter for a second

The curve is at its steepest at the midpoint. The curve is accelerating, hits the midpoint, then starts decelerating. 

This is the derivative of the logistic curve. I had to ask a computer to do the math for me. 

$$\frac{d}{dt}f(t) =  \text{asymptote} * \frac{ \text{scale} * \exp{((\text{mid}~-~t)~*~\text{scale})}}{(1 + \exp{((\text{mid}~-~t)~*~\text{scale})})^2}$$

Yeah, I don't like it either, but I have to show you this mess to show how neat
the midpoint of the curve is. When *t* is the midpoint, algebraic magic happens.
All of the (mid − *t*) parts become 0, exp(0) is 1, so everything simplifies a
great deal. Check it out.

$$
\begin{align}
\frac{d}{dt}f(t = \text{mid}) &=  \text{asymptote} * \frac{ \text{scale} * \exp{(0~*~\text{scale})}}{(1 + \exp{(0~*~\text{scale}}))^2} \\
&= \text{asymptote} * \frac{ \text{scale} * 1}{(1 + 1)^2} \\
&= \text{asymptote} * \frac{ \text{scale}}{4} \\
\text{slope at midpoint} &= \text{asymptote} * \frac{ \text{scale}}{4} \\
\end{align}
$$











```{r}
# Compute endpoints for segment for slope in middle
slope <- (.2 / 4) * .8
x_step <- 2.5
y1 <- .4 + slope * -x_step
y2 <- .4 + slope * x_step

p <- p +
  geom_segment(
    x = 48 - x_step, xend = 48 + x_step,
    y = y1, yend = y2,
    size = 1.2,
    color = colors$scale,
    arrow = arrow(ends = "both", length = unit(.1, "in"))) +
  annotate(
    "text",
    label = "scale controls slope of curve",
    x = 49, y = .36, 
    color = colors$scale, hjust = 0)
```




```{r}
# Helper to plot an equation a specified spot
annotate_eq <- function(label, ...) {
  annotate(
    "text",
    x = 0,
    y = .6,
    label = label,
    parse = TRUE,
    hjust = 0,
    size = 4, ...)
}


p <- last_plot()

p + annotate_eq(
    label = "f(t)==frac(asymptote, (1 + exp(mid-t)%*%scale))", 
    color = colors$fit)


# Use phantom to invisibly write characters. I think it only works on whole
# expressions so I have to do some ridiculous stuff like adding spaces with \~
# to get things to line up.
# frac() draws a fraction line. atop() does not.
p +
  annotate_eq(
    label = "
    f(t)==frac(
    phantom(asymptote), 
    (1 + exp((phantom(mid)-t)%*%phantom(scale)))
    )",
    color = colors$fit) +
  annotate_eq(
    label = "phantom(f(t))~atop(asymptote, phantom((1 + exp((mid-t)%*%scale))))",
    color = colors$asym) +
  annotate_eq(
    label = "phantom(f(t))~atop(phantom(asymptote), phantom(1 + exp((mid-t11)))~~scale)",
    color = colors$scale) +
  annotate_eq(
    label = "phantom(f(t))~atop(phantom(asymptote), phantom(1 + exp)~~~~~~~~mid~phantom(t*scale))",
    color = colors$mid)
```

Using `phantom(x)` will make space for x in the equation but it won't draw it.
So we can `phantom()` out all of the parameters to draw the non-parameter parts
of the equation in black.

```{r}
p1 <- p +
  annotate_eq(
    label = "
    f(t)==frac(phantom(asymptote), 
    (1 + exp((phantom(mid)-t)%*%phantom(scale))))", 
    color = colors$fit) 
p1
```

Then we layer on the other parts of the equation, but use `phantom()` as needed

```{r}


p2 <- p1 + 
  annotate_eq(
    label = "phantom(f(t))~atop(asymptote, phantom((1 + exp((mid-t)%*%scale))))",
    color = colors$asym)

p2 +
  annotate_eq(
    label = "
    phantom(f(t), symbol('=')) ~ 
    atop(
      phantom(asymptote), 
      phantom(1 + exp((mid-t), symbol(')'), symbol('*'))) ~ scale)",
    color = colors$scale) +
  annotate_eq(
    label = "phantom(f(t))~atop(phantom(asymptote), phantom(1 + exp)~~~~~~~~mid~phantom(t*scale))",
    color = colors$mid)
```


```{r, eval = FALSE, echo = FALSE}
library(tidyverse)
library(rstan)
library(brms)
library(tidybayes)

# The next few lines just follow advice from RStan

options(mc.cores = 4)
rstan_options(auto_write = TRUE)
Sys.setenv(LOCAL_CPPFLAGS = '-march=native')

f0 <- bf(
  prop ~ asym * inv(1 + exp((mid - age) * scale)),
  asym ~ 1,
  mid ~ 1,
  scale ~ 1,
  nl = TRUE)

prior_fixef <- c(
  prior(beta(8, 2), nlpar = "asym", coef = "Intercept"),
  prior(normal(50, 6), nlpar = "mid", coef = "Intercept"),
  prior(normal(2, .5), nlpar = "scale", coef = "Intercept")
)

plogis(rnorm(1000, 1, .5))
mean(plogis(rnorm(1000, 1, .5)))
plot(density(rbeta(1000, 8, 2)))
beta()

# prior_phi <- c(
#   prior(normal(2, 1), dpar = "phi", class = "Intercept")
# )

fit_beta <- brm(
  f0,
  data = points,
  prior = c(prior_fixef),
  family = Beta(link = identity),
  iter = 2000,
  chains = 4,
  control = list(adapt_delta = 0.90, max_treedepth = 15))
fit_beta


fit_draw <- fit_beta


points %>%
  tidyr::expand(
    age = seq(0, 96, length.out = 80)) %>%
  tidybayes::add_fitted_draws(
    fit_draw,
    n = 1000) %>%
  ggplot() +
    aes(x = age, y = .value) +
    stat_summary(fun.data = median_hdci) +
    geom_point(aes(y = prop), data = points) 

points %>%
  tidyr::expand(
    age = seq(0, 96, length.out = 80)) %>%
  tidybayes::add_fitted_draws(
    fit_draw,
    n = 40) %>%
  ggplot() +
    aes(x = age, y = .value) +
    geom_line(aes(group = .draw), alpha = .1) +
      # stat_summary(fun.data = median_hdci) +
    geom_point(aes(y = prop), data = points) 

intels <- d %>%
  distinct(age, sid, intel2)

summary <- d %>%
  tidyr::expand(
    age = seq(24, max(age), by = 1),
    nesting(slpg, sid)) %>%
  tidybayes::add_fitted_draws(fit_draw, n = 1000) %>%
  ungroup()


```


## Extra notes


### Gelman's divide by four rule

In Gelman and Hill, a textbook I've mentioned a few times on this blog, they use these feature in their chapter on logistic regression. ...


```{r}


# crossing(
#   xs = xs,
#   asymptote = c(.4, .6, .8),
#   scale = c(-0.05, .1, .2, .3),
#   midpoint = c(40)
#   
#   ) %>% 
#   mutate(
#     ys = asymptote / (1 + exp((midpoint - xs) * scale))) %>% 
#   ggplot() + 
#   aes(x = xs, y = ys, group = interaction(asymptote, midpoint, scale)) + 
#   geom_line(aes(color = factor(scale)))


```


This curve is flexible enough to capture many patterns—for example, sudden
growth (sharp slope), delay (later midpoint), or no change at all (low
asymptote)—so these parameters provide a way to estimate individual differences
in developmental trajectories.
